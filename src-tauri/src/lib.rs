mod commands;

use std::env;
use std::sync::Mutex;
use tauri::State;
use commands::{get_recent_files, open_file, read_file, read_settings, save_file, save_file_as, write_settings};

// Глобальное состояние для хранения пути к файлу, переданному при запуске
struct PendingFilePath(Mutex<Option<String>>);

#[tauri::command]
fn get_pending_file(state: State<PendingFilePath>) -> Option<String> {
  state.0.lock().unwrap().take()
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
  // Проверяем аргументы командной строки при запуске
  let args: Vec<String> = env::args().collect();
  let pending_file = if args.len() > 1 {
    let file_path = args[1].clone();
    // Проверяем, что это действительно путь к файлу markdown
    if file_path.ends_with(".md") 
      || file_path.ends_with(".markdown") 
      || file_path.ends_with(".mdown") 
      || file_path.ends_with(".mkd")
      || file_path.ends_with(".txt") {
      Some(file_path)
    } else {
      None
    }
  } else {
    None
  };

  tauri::Builder::default()
    .plugin(tauri_plugin_dialog::init())
    .plugin(tauri_plugin_fs::init())
    .plugin(tauri_plugin_opener::init())
    .plugin(tauri_plugin_store::Builder::default().build())
    .manage(PendingFilePath(Mutex::new(pending_file)))
    .invoke_handler(tauri::generate_handler![
      open_file,
      save_file,
      save_file_as,
      read_settings,
      write_settings,
      get_recent_files,
      read_file,
      get_pending_file,
    ])
    .run(tauri::generate_context!())
    .expect("Ошибка запуска приложения");
}
